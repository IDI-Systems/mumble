// Copyright 2020 The Mumble Developers. All rights reserved.
// Use of this source code is governed by a BSD-style license
// that can be found in the LICENSE file at the root of the
// Mumble source tree or at <https://www.mumble.info/LICENSE>

// This code has been automatically generated via scripts/generateProtoValidator.py on 2020-04-17
// DO NOT EDIT THIS FILE MANUALLY

// This file contains validation functions for the ProtoMessages of package MumbleProto

#include "ProtoValidator.h"

#include <QtGlobal>

namespace ProtoValidator {
	// Restrict the size of any string that we'll accept
	const size_t MAX_STRING_LENGTH = 5000;

	bool isValid(const MumbleProto::Version &msg) {
		if (msg.release().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		if (msg.os().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		if (msg.os_version().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		// No check for field version

		return true;
	}

	bool makeValid(MumbleProto::Version &msg) {
		bool changed = false;

		if (msg.release().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_release(msg.release().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		if (msg.os().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_os(msg.os().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		if (msg.os_version().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_os_version(msg.os_version().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		// No check for field version

		if (changed) {
			qWarning("ProtoValidator: Changed message \"Version\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::UDPTunnel &msg) {
		// No check for field packet
		Q_UNUSED(msg);

		return true;
	}

	bool makeValid(MumbleProto::UDPTunnel &msg) {
		bool changed = false;

		// No check for field packet
		Q_UNUSED(msg);

		if (changed) {
			qWarning("ProtoValidator: Changed message \"UDPTunnel\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::Authenticate &msg) {
		if (msg.username().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		if (msg.password().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		for (int i = 0; i < msg.tokens_size(); i++) {
			if (msg.tokens(i).size() > MAX_STRING_LENGTH) {
				return false;
			}
		}
		
		// No check for field celt_versions
		// No check for field opus

		return true;
	}

	bool makeValid(MumbleProto::Authenticate &msg) {
		bool changed = false;

		if (msg.username().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_username(msg.username().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		if (msg.password().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_password(msg.password().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		for (int i = 0; i < msg.tokens_size(); i++) {
			if (msg.tokens(i).size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
				*msg.mutable_tokens(i) = msg.tokens(i).substr(0, MAX_STRING_LENGTH);
		
				changed = true;
			}
		}
		
		// No check for field celt_versions
		// No check for field opus

		if (changed) {
			qWarning("ProtoValidator: Changed message \"Authenticate\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::Ping &msg) {
		// No check for field timestamp
		// No check for field good
		// No check for field late
		// No check for field lost
		// No check for field resync
		// No check for field udp_packets
		// No check for field tcp_packets
		// No check for field udp_ping_avg
		// No check for field udp_ping_var
		// No check for field tcp_ping_avg
		// No check for field tcp_ping_var
		Q_UNUSED(msg);

		return true;
	}

	bool makeValid(MumbleProto::Ping &msg) {
		bool changed = false;

		// No check for field timestamp
		// No check for field good
		// No check for field late
		// No check for field lost
		// No check for field resync
		// No check for field udp_packets
		// No check for field tcp_packets
		// No check for field udp_ping_avg
		// No check for field udp_ping_var
		// No check for field tcp_ping_avg
		// No check for field tcp_ping_var
		Q_UNUSED(msg);

		if (changed) {
			qWarning("ProtoValidator: Changed message \"Ping\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::Reject &msg) {
		if (msg.reason().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		// No check for field type

		return true;
	}

	bool makeValid(MumbleProto::Reject &msg) {
		bool changed = false;

		if (msg.reason().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_reason(msg.reason().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		// No check for field type

		if (changed) {
			qWarning("ProtoValidator: Changed message \"Reject\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::ServerSync &msg) {
		// Don't restrict the welcome message as it might have images embedded which can easily exceed the normal message length
		
		// No check for field session
		// No check for field max_bandwidth
		// No check for field welcome_text
		// No check for field permissions
		Q_UNUSED(msg);

		return true;
	}

	bool makeValid(MumbleProto::ServerSync &msg) {
		bool changed = false;

		// Don't restrict the welcome message as it might have images embedded which can easily exceed the normal message length
		
		// No check for field session
		// No check for field max_bandwidth
		// No check for field welcome_text
		// No check for field permissions
		Q_UNUSED(msg);

		if (changed) {
			qWarning("ProtoValidator: Changed message \"ServerSync\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::ChannelRemove &msg) {
		// No check for field channel_id
		Q_UNUSED(msg);

		return true;
	}

	bool makeValid(MumbleProto::ChannelRemove &msg) {
		bool changed = false;

		// No check for field channel_id
		Q_UNUSED(msg);

		if (changed) {
			qWarning("ProtoValidator: Changed message \"ChannelRemove\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::ChannelState &msg) {
		if (msg.name().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		// The field "description" in the "ChannelState" message is validated by Server::isTextAllowed so no additional validation is necessary
		
		// No check for field channel_id
		// No check for field parent
		// No check for field links
		// No check for field description
		// No check for field links_add
		// No check for field links_remove
		// No check for field temporary
		// No check for field position
		// No check for field description_hash
		// No check for field max_users
		// No check for field is_enter_restricted
		// No check for field can_enter

		return true;
	}

	bool makeValid(MumbleProto::ChannelState &msg) {
		bool changed = false;

		if (msg.name().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_name(msg.name().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		// The field "description" in the "ChannelState" message is validated by Server::isTextAllowed so no additional validation is necessary
		
		// No check for field channel_id
		// No check for field parent
		// No check for field links
		// No check for field description
		// No check for field links_add
		// No check for field links_remove
		// No check for field temporary
		// No check for field position
		// No check for field description_hash
		// No check for field max_users
		// No check for field is_enter_restricted
		// No check for field can_enter

		if (changed) {
			qWarning("ProtoValidator: Changed message \"ChannelState\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::UserRemove &msg) {
		if (msg.reason().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		// No check for field session
		// No check for field actor
		// No check for field ban

		return true;
	}

	bool makeValid(MumbleProto::UserRemove &msg) {
		bool changed = false;

		if (msg.reason().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_reason(msg.reason().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		// No check for field session
		// No check for field actor
		// No check for field ban

		if (changed) {
			qWarning("ProtoValidator: Changed message \"UserRemove\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::UserState &msg) {
		if (msg.name().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		if (msg.plugin_identity().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		// The field "comment" in the "UserState" message is validated by Server::isTextAllowed so no additional validation is necessary
		
		if (msg.hash().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		for (int i = 0; i < msg.temporary_access_tokens_size(); i++) {
			if (msg.temporary_access_tokens(i).size() > MAX_STRING_LENGTH) {
				return false;
			}
		}
		
		// No check for field session
		// No check for field actor
		// No check for field user_id
		// No check for field channel_id
		// No check for field mute
		// No check for field deaf
		// No check for field suppress
		// No check for field self_mute
		// No check for field self_deaf
		// No check for field texture
		// No check for field plugin_context
		// No check for field comment
		// No check for field comment_hash
		// No check for field texture_hash
		// No check for field priority_speaker
		// No check for field recording
		// No check for field listening_channel_add
		// No check for field listening_channel_remove

		return true;
	}

	bool makeValid(MumbleProto::UserState &msg) {
		bool changed = false;

		if (msg.name().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_name(msg.name().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		if (msg.plugin_identity().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_plugin_identity(msg.plugin_identity().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		// The field "comment" in the "UserState" message is validated by Server::isTextAllowed so no additional validation is necessary
		
		if (msg.hash().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_hash(msg.hash().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		for (int i = 0; i < msg.temporary_access_tokens_size(); i++) {
			if (msg.temporary_access_tokens(i).size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
				*msg.mutable_temporary_access_tokens(i) = msg.temporary_access_tokens(i).substr(0, MAX_STRING_LENGTH);
		
				changed = true;
			}
		}
		
		// No check for field session
		// No check for field actor
		// No check for field user_id
		// No check for field channel_id
		// No check for field mute
		// No check for field deaf
		// No check for field suppress
		// No check for field self_mute
		// No check for field self_deaf
		// No check for field texture
		// No check for field plugin_context
		// No check for field comment
		// No check for field comment_hash
		// No check for field texture_hash
		// No check for field priority_speaker
		// No check for field recording
		// No check for field listening_channel_add
		// No check for field listening_channel_remove

		if (changed) {
			qWarning("ProtoValidator: Changed message \"UserState\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::BanList::BanEntry &msg) {
		if (msg.name().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		if (msg.hash().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		if (msg.reason().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		if (msg.start().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		// No check for field address
		// No check for field mask
		// No check for field duration

		return true;
	}

	bool makeValid(MumbleProto::BanList::BanEntry &msg) {
		bool changed = false;

		if (msg.name().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_name(msg.name().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		if (msg.hash().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_hash(msg.hash().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		if (msg.reason().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_reason(msg.reason().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		if (msg.start().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_start(msg.start().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		// No check for field address
		// No check for field mask
		// No check for field duration

		if (changed) {
			qWarning("ProtoValidator: Changed message \"BanList::BanEntry\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::BanList &msg) {
		for (int i = 0; i < msg.bans_size(); i++) {
			if (!isValid(msg.bans(i))) {
				return false;
			}
		}
		
		// No check for field query

		return true;
	}

	bool makeValid(MumbleProto::BanList &msg) {
		bool changed = false;

		for (int i = 0; i < msg.bans_size(); i++) {
			changed = changed || makeValid(*msg.mutable_bans(i));
		}
		
		// No check for field query

		if (changed) {
			qWarning("ProtoValidator: Changed message \"BanList\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::TextMessage &msg) {
		// The field "message" in the "TextMessage" message is validated by Server::isTextAllowed so no additional validation is necessary
		
		// No check for field actor
		// No check for field session
		// No check for field channel_id
		// No check for field tree_id
		// No check for field message
		Q_UNUSED(msg);

		return true;
	}

	bool makeValid(MumbleProto::TextMessage &msg) {
		bool changed = false;

		// The field "message" in the "TextMessage" message is validated by Server::isTextAllowed so no additional validation is necessary
		
		// No check for field actor
		// No check for field session
		// No check for field channel_id
		// No check for field tree_id
		// No check for field message
		Q_UNUSED(msg);

		if (changed) {
			qWarning("ProtoValidator: Changed message \"TextMessage\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::PermissionDenied &msg) {
		if (msg.reason().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		if (msg.name().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		// No check for field permission
		// No check for field channel_id
		// No check for field session
		// No check for field type

		return true;
	}

	bool makeValid(MumbleProto::PermissionDenied &msg) {
		bool changed = false;

		if (msg.reason().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_reason(msg.reason().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		if (msg.name().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_name(msg.name().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		// No check for field permission
		// No check for field channel_id
		// No check for field session
		// No check for field type

		if (changed) {
			qWarning("ProtoValidator: Changed message \"PermissionDenied\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::ACL::ChanGroup &msg) {
		if (msg.name().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		// No check for field inherited
		// No check for field inherit
		// No check for field inheritable
		// No check for field add
		// No check for field remove
		// No check for field inherited_members

		return true;
	}

	bool makeValid(MumbleProto::ACL::ChanGroup &msg) {
		bool changed = false;

		if (msg.name().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_name(msg.name().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		// No check for field inherited
		// No check for field inherit
		// No check for field inheritable
		// No check for field add
		// No check for field remove
		// No check for field inherited_members

		if (changed) {
			qWarning("ProtoValidator: Changed message \"ACL::ChanGroup\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::ACL::ChanACL &msg) {
		if (msg.group().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		// No check for field apply_here
		// No check for field apply_subs
		// No check for field inherited
		// No check for field user_id
		// No check for field grant
		// No check for field deny

		return true;
	}

	bool makeValid(MumbleProto::ACL::ChanACL &msg) {
		bool changed = false;

		if (msg.group().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_group(msg.group().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		// No check for field apply_here
		// No check for field apply_subs
		// No check for field inherited
		// No check for field user_id
		// No check for field grant
		// No check for field deny

		if (changed) {
			qWarning("ProtoValidator: Changed message \"ACL::ChanACL\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::ACL &msg) {
		for (int i = 0; i < msg.groups_size(); i++) {
			if (!isValid(msg.groups(i))) {
				return false;
			}
		}
		
		for (int i = 0; i < msg.acls_size(); i++) {
			if (!isValid(msg.acls(i))) {
				return false;
			}
		}
		
		// No check for field channel_id
		// No check for field inherit_acls
		// No check for field query

		return true;
	}

	bool makeValid(MumbleProto::ACL &msg) {
		bool changed = false;

		for (int i = 0; i < msg.groups_size(); i++) {
			changed = changed || makeValid(*msg.mutable_groups(i));
		}
		
		for (int i = 0; i < msg.acls_size(); i++) {
			changed = changed || makeValid(*msg.mutable_acls(i));
		}
		
		// No check for field channel_id
		// No check for field inherit_acls
		// No check for field query

		if (changed) {
			qWarning("ProtoValidator: Changed message \"ACL\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::QueryUsers &msg) {
		for (int i = 0; i < msg.names_size(); i++) {
			if (msg.names(i).size() > MAX_STRING_LENGTH) {
				return false;
			}
		}
		
		// No check for field ids

		return true;
	}

	bool makeValid(MumbleProto::QueryUsers &msg) {
		bool changed = false;

		for (int i = 0; i < msg.names_size(); i++) {
			if (msg.names(i).size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
				*msg.mutable_names(i) = msg.names(i).substr(0, MAX_STRING_LENGTH);
		
				changed = true;
			}
		}
		
		// No check for field ids

		if (changed) {
			qWarning("ProtoValidator: Changed message \"QueryUsers\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::CryptSetup &msg) {
		// No check for field key
		// No check for field client_nonce
		// No check for field server_nonce
		Q_UNUSED(msg);

		return true;
	}

	bool makeValid(MumbleProto::CryptSetup &msg) {
		bool changed = false;

		// No check for field key
		// No check for field client_nonce
		// No check for field server_nonce
		Q_UNUSED(msg);

		if (changed) {
			qWarning("ProtoValidator: Changed message \"CryptSetup\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::ContextActionModify &msg) {
		if (msg.action().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		if (msg.text().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		// No check for field context
		// No check for field operation

		return true;
	}

	bool makeValid(MumbleProto::ContextActionModify &msg) {
		bool changed = false;

		if (msg.action().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_action(msg.action().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		if (msg.text().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_text(msg.text().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		// No check for field context
		// No check for field operation

		if (changed) {
			qWarning("ProtoValidator: Changed message \"ContextActionModify\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::ContextAction &msg) {
		if (msg.action().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		// No check for field session
		// No check for field channel_id

		return true;
	}

	bool makeValid(MumbleProto::ContextAction &msg) {
		bool changed = false;

		if (msg.action().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_action(msg.action().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		// No check for field session
		// No check for field channel_id

		if (changed) {
			qWarning("ProtoValidator: Changed message \"ContextAction\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::UserList::User &msg) {
		if (msg.name().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		if (msg.last_seen().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		// No check for field user_id
		// No check for field last_channel

		return true;
	}

	bool makeValid(MumbleProto::UserList::User &msg) {
		bool changed = false;

		if (msg.name().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_name(msg.name().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		if (msg.last_seen().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_last_seen(msg.last_seen().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		// No check for field user_id
		// No check for field last_channel

		if (changed) {
			qWarning("ProtoValidator: Changed message \"UserList::User\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::UserList &msg) {
		for (int i = 0; i < msg.users_size(); i++) {
			if (!isValid(msg.users(i))) {
				return false;
			}
		}

		return true;
	}

	bool makeValid(MumbleProto::UserList &msg) {
		bool changed = false;

		for (int i = 0; i < msg.users_size(); i++) {
			changed = changed || makeValid(*msg.mutable_users(i));
		}

		if (changed) {
			qWarning("ProtoValidator: Changed message \"UserList\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::VoiceTarget::Target &msg) {
		if (msg.group().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		// No check for field session
		// No check for field channel_id
		// No check for field links
		// No check for field children

		return true;
	}

	bool makeValid(MumbleProto::VoiceTarget::Target &msg) {
		bool changed = false;

		if (msg.group().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_group(msg.group().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		// No check for field session
		// No check for field channel_id
		// No check for field links
		// No check for field children

		if (changed) {
			qWarning("ProtoValidator: Changed message \"VoiceTarget::Target\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::VoiceTarget &msg) {
		for (int i = 0; i < msg.targets_size(); i++) {
			if (!isValid(msg.targets(i))) {
				return false;
			}
		}
		
		// No check for field id

		return true;
	}

	bool makeValid(MumbleProto::VoiceTarget &msg) {
		bool changed = false;

		for (int i = 0; i < msg.targets_size(); i++) {
			changed = changed || makeValid(*msg.mutable_targets(i));
		}
		
		// No check for field id

		if (changed) {
			qWarning("ProtoValidator: Changed message \"VoiceTarget\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::PermissionQuery &msg) {
		// No check for field channel_id
		// No check for field permissions
		// No check for field flush
		Q_UNUSED(msg);

		return true;
	}

	bool makeValid(MumbleProto::PermissionQuery &msg) {
		bool changed = false;

		// No check for field channel_id
		// No check for field permissions
		// No check for field flush
		Q_UNUSED(msg);

		if (changed) {
			qWarning("ProtoValidator: Changed message \"PermissionQuery\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::CodecVersion &msg) {
		// No check for field alpha
		// No check for field beta
		// No check for field prefer_alpha
		// No check for field opus
		Q_UNUSED(msg);

		return true;
	}

	bool makeValid(MumbleProto::CodecVersion &msg) {
		bool changed = false;

		// No check for field alpha
		// No check for field beta
		// No check for field prefer_alpha
		// No check for field opus
		Q_UNUSED(msg);

		if (changed) {
			qWarning("ProtoValidator: Changed message \"CodecVersion\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::UserStats::Stats &msg) {
		// No check for field good
		// No check for field late
		// No check for field lost
		// No check for field resync
		Q_UNUSED(msg);

		return true;
	}

	bool makeValid(MumbleProto::UserStats::Stats &msg) {
		bool changed = false;

		// No check for field good
		// No check for field late
		// No check for field lost
		// No check for field resync
		Q_UNUSED(msg);

		if (changed) {
			qWarning("ProtoValidator: Changed message \"UserStats::Stats\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::UserStats &msg) {
		if (!isValid(msg.from_client())) {
			return false;
		}
		
		if (!isValid(msg.from_server())) {
			return false;
		}
		
		if (!isValid(msg.version())) {
			return false;
		}
		
		// No check for field session
		// No check for field stats_only
		// No check for field certificates
		// No check for field udp_packets
		// No check for field tcp_packets
		// No check for field udp_ping_avg
		// No check for field udp_ping_var
		// No check for field tcp_ping_avg
		// No check for field tcp_ping_var
		// No check for field celt_versions
		// No check for field address
		// No check for field bandwidth
		// No check for field onlinesecs
		// No check for field idlesecs
		// No check for field strong_certificate
		// No check for field opus

		return true;
	}

	bool makeValid(MumbleProto::UserStats &msg) {
		bool changed = false;

		if (!isValid(msg.from_client())) {
			changed = changed || makeValid(*msg.mutable_from_client());
		}
		
		if (!isValid(msg.from_server())) {
			changed = changed || makeValid(*msg.mutable_from_server());
		}
		
		if (!isValid(msg.version())) {
			changed = changed || makeValid(*msg.mutable_version());
		}
		
		// No check for field session
		// No check for field stats_only
		// No check for field certificates
		// No check for field udp_packets
		// No check for field tcp_packets
		// No check for field udp_ping_avg
		// No check for field udp_ping_var
		// No check for field tcp_ping_avg
		// No check for field tcp_ping_var
		// No check for field celt_versions
		// No check for field address
		// No check for field bandwidth
		// No check for field onlinesecs
		// No check for field idlesecs
		// No check for field strong_certificate
		// No check for field opus

		if (changed) {
			qWarning("ProtoValidator: Changed message \"UserStats\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::RequestBlob &msg) {
		// No check for field session_texture
		// No check for field session_comment
		// No check for field channel_description
		Q_UNUSED(msg);

		return true;
	}

	bool makeValid(MumbleProto::RequestBlob &msg) {
		bool changed = false;

		// No check for field session_texture
		// No check for field session_comment
		// No check for field channel_description
		Q_UNUSED(msg);

		if (changed) {
			qWarning("ProtoValidator: Changed message \"RequestBlob\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::ServerConfig &msg) {
		if (msg.welcome_text().size() > MAX_STRING_LENGTH) {
			return false;
		}
		
		// No check for field max_bandwidth
		// No check for field allow_html
		// No check for field message_length
		// No check for field image_message_length
		// No check for field max_users

		return true;
	}

	bool makeValid(MumbleProto::ServerConfig &msg) {
		bool changed = false;

		if (msg.welcome_text().size() > MAX_STRING_LENGTH) {
			// Only use a substring as the original String is too long
			msg.set_welcome_text(msg.welcome_text().substr(0, MAX_STRING_LENGTH));
		
			changed = true;
		}
		
		// No check for field max_bandwidth
		// No check for field allow_html
		// No check for field message_length
		// No check for field image_message_length
		// No check for field max_users

		if (changed) {
			qWarning("ProtoValidator: Changed message \"ServerConfig\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

	bool isValid(const MumbleProto::SuggestConfig &msg) {
		// No check for field version
		// No check for field positional
		// No check for field push_to_talk
		Q_UNUSED(msg);

		return true;
	}

	bool makeValid(MumbleProto::SuggestConfig &msg) {
		bool changed = false;

		// No check for field version
		// No check for field positional
		// No check for field push_to_talk
		Q_UNUSED(msg);

		if (changed) {
			qWarning("ProtoValidator: Changed message \"SuggestConfig\" to make it valid - this might have corrupted data...");
		}

		return changed;
	}

}; // namespace ProtoValidator
